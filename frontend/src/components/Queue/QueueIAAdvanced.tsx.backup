
import React, { useState, useEffect } from 'react';
import { 
  ArrowPathIcon, TrashIcon, PauseIcon, PlayIcon, XMarkIcon,
  ClockIcon,
  CogIcon, FunnelIcon,
  CpuChipIcon, DocumentIcon, EyeIcon, ChatBubbleLeftRightIcon,
  DocumentDuplicateIcon, EyeSlashIcon, Squares2X2Icon
} from '@heroicons/react/24/outline';
import { useColors } from '../../hooks/useColors';
import { useQueueStore } from '../../stores/queueStore';
import { usePromptStore } from '../../stores/promptStore';
import { useConfigStore } from '../../stores/configStore';
import { useSimpleConfirm } from '../../hooks/useSimpleConfirm';
import { queueService } from '../../services/queueService';
import { pdfService } from '../../services/pdfService';
import { logService } from '../../services/logService';
import { formatFileSize } from '../../utils/fileUtils';
import { UnifiedTable, TableColumn } from '../UI/UnifiedTable';
import { Button, IconButton } from '../UI/Button';
import { Prompt } from '../../services/promptService';



// Composant pour afficher les informations du fichier (compact)
const FileInfo: React.FC<{ 
  item: any; 
  colors: any; 
}> = ({ 
  item, 
  colors
}) => {
  return (
    <div className="space-y-1">
      {/* Nom du fichier */}
      <div className="flex items-center gap-2">
        <DocumentIcon className="w-4 h-4" style={{ color: colors.textSecondary }} />
        <span className="text-sm font-medium truncate" style={{ color: colors.text }}>
          {item.file_info?.name || 'N/A'}
        </span>
      </div>
      
      {/* Taille et type */}
      <div className="flex items-center justify-between text-xs">
        <span style={{ color: colors.textSecondary }}>
          {item.file_info?.size ? formatFileSize(item.file_info.size) : ''}
        </span>
        <span style={{ color: colors.textSecondary }}>
          {item.file_info?.mime_type || ''}
        </span>
      </div>
      
      {/* Date de cr√©ation */}
      <div className="flex items-center gap-1 text-xs">
        <ClockIcon className="w-3 h-3" style={{ color: colors.textSecondary }} />
        <span style={{ color: colors.textSecondary }}>
          {new Date(item.created_at).toLocaleString('fr-FR')}
        </span>
      </div>
    </div>
  );
};

// Composant pour la configuration compacte (IA + Prompt en ligne)
const ConfigurationCompact: React.FC<{
  item: any;
  colors: any;
  prompts: Prompt[];
  onProviderChange: (itemId: string, provider: string) => void;
  onPromptChange: (itemId: string, promptId: string) => void;
  localSelections: { [itemId: string]: { provider?: string; prompt?: string } };
}> = ({ item, colors, prompts, onProviderChange, onPromptChange, localSelections }) => {
  const { getAIProviders } = useConfigStore();
  const allAIProviders = getAIProviders();
  
  // Organiser les providers par type (local/web) et trier alphab√©tiquement
  const localProviders = allAIProviders
    .filter(provider => provider.name.toLowerCase() === 'ollama')
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(provider => ({
      id: provider.name,
      name: getProviderDisplayName(provider.name),
      available: provider.is_active && provider.is_functional,
      type: 'local'
    }));
    
  const webProviders = allAIProviders
    .filter(provider => provider.name.toLowerCase() !== 'ollama')
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(provider => ({
      id: provider.name,
      name: getProviderDisplayName(provider.name),
      available: provider.is_active && provider.is_functional,
      type: 'web'
    }));
  
  // Combiner avec s√©parateur
  const allProvidersWithStatus = [
    ...(localProviders.length > 0 ? [{
      id: 'separator-local',
      name: '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ IA Locale ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ',
      available: false,
      type: 'separator'
    }] : []),
    ...localProviders,
    ...(localProviders.length > 0 && webProviders.length > 0 ? [{
      id: 'separator-web',
      name: '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ IA Web ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ',
      available: false,
      type: 'separator'
    }] : []),
    ...webProviders
  ];
  
  function getProviderDisplayName(providerName: string): string {
    const displayNames: { [key: string]: string } = {
      'openai': 'OpenAI GPT',
      'claude': 'Claude',
      'mistral': 'Mistral',
      'ollama': 'Ollama',
      'gemini': 'Google Gemini'
    };
    return displayNames[providerName] || providerName;
  }
  
  // Utiliser les s√©lections locales ou les valeurs par d√©faut
  const localSelection = localSelections[item.id] || {};
  let selectedProvider = localSelection.provider !== undefined ? localSelection.provider : (item.analysis_provider || '');
  
  // S'assurer que la valeur s√©lectionn√©e est dans la liste des options disponibles
  if (selectedProvider && !allProvidersWithStatus.some(p => p.id === selectedProvider)) {
    console.warn(`Provider ${selectedProvider} non trouv√© dans les options disponibles:`, allProvidersWithStatus.map(p => p.id));
    selectedProvider = ''; // R√©initialiser si non trouv√©
  }
  
  // Debug temporaire pour voir les fournisseurs IA disponibles
  console.log(`üîç Fournisseurs IA pour item ${item.id}:`, {
    allProvidersWithStatus: allProvidersWithStatus.map(p => ({ id: p.id, name: p.name, available: p.available })),
    selectedProvider,
    itemProvider: item.analysis_provider,
    localSelection: localSelection,
    // Debug sp√©cifique pour comprendre le probl√®me
    debug: {
      hasLocalSelection: !!localSelection.provider,
      localSelectionProvider: localSelection.provider,
      itemAnalysisProvider: item.analysis_provider,
      finalSelectedProvider: selectedProvider,
      isProviderInAvailable: allProvidersWithStatus.some(p => p.id === selectedProvider && p.available),
      // Debug du select
      selectValue: selectedProvider,
      selectOptions: allProvidersWithStatus.map(p => ({ value: p.id, label: p.name, available: p.available }))
    }
  });
  
  // Pour les prompts, on doit trouver l'ID correspondant au contenu
  let selectedPromptId = '';
  if (localSelection.prompt !== undefined) {
    selectedPromptId = localSelection.prompt;
  } else if (item.analysis_prompt) {
    // Chercher le prompt par son contenu
    const matchingPrompt = prompts.find(p => p.prompt === item.analysis_prompt);
    selectedPromptId = matchingPrompt?.id || '';
  }
  

  

  

  

  
  return (
    <div className="space-y-2">
      {/* Fournisseur IA */}
      <div className="flex items-center gap-2">
        <CpuChipIcon className="w-4 h-4" style={{ color: colors.textSecondary }} />
                 <select
           value={selectedProvider}
           onChange={(e) => onProviderChange(item.id, e.target.value)}
           className="flex-1 px-2 py-1 text-xs rounded border"
           style={{
             backgroundColor: colors.background,
             borderColor: colors.border,
             color: colors.text
           }}
         >
           {allProvidersWithStatus.map(provider => {
             if (provider.type === 'separator') {
               return (
                 <option key={provider.id} value="" disabled style={{ color: '#6b7280', fontStyle: 'italic' }}>
                   {provider.name}
                 </option>
               );
             }
             return (
               <option 
                 key={provider.id} 
                 value={provider.id}
                 style={{
                   color: provider.available ? '#10b981' : '#ef4444', // Vert si disponible, rouge si non disponible
                   fontWeight: provider.type === 'local' ? 'bold' : 'normal'
                 }}
               >
                 {provider.type === 'local' ? 'üè† ' : 'üåê '}{provider.name}
               </option>
             );
           })}
         </select>
         
      </div>
      
      {/* Prompt organis√© par sections */}
      <div className="flex items-center gap-2">
        <ChatBubbleLeftRightIcon className="w-4 h-4" style={{ color: colors.textSecondary }} />
        <select
          value={selectedPromptId}
          onChange={(e) => onPromptChange(item.id, e.target.value)}
          className="flex-1 px-2 py-1 text-xs rounded border"
          style={{
            backgroundColor: colors.background,
            borderColor: colors.border,
            color: colors.text
          }}
        >
          {(() => {
            // Organiser les prompts par domaine
            const domains = [...new Set(prompts.map(p => p.domain))];
            const organized: { [domain: string]: any[] } = {};
            
            domains.forEach(domain => {
              organized[domain] = prompts.filter(p => p.domain === domain);
            });
            
            // D√©terminer le type de fichier pour la s√©lection automatique
            const fileName = item.file_info?.name || '';
            const fileExtension = fileName.split('.').pop()?.toLowerCase() || '';
            let fileType = 'text';
            
            if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg'].includes(fileExtension)) {
              fileType = 'image';
            } else if (['mp4', 'avi', 'mov', 'wmv', 'flv', 'webm', 'mkv'].includes(fileExtension)) {
              fileType = 'video';
            } else if (['mp3', 'wav', 'flac', 'aac', 'ogg', 'wma'].includes(fileExtension)) {
              fileType = 'audio';
            } else if (['pdf', 'doc', 'docx', 'txt', 'rtf', 'odt'].includes(fileExtension)) {
              fileType = 'document';
            }
            
            // Si aucun prompt n'est s√©lectionn√©, s√©lectionner automatiquement un prompt bas√© sur le type de fichier
            if (!selectedPromptId) {
              const domainMap: { [key: string]: string } = {
                'image': 'image',
                'video': 'video', 
                'audio': 'audio',
                'document': 'document',
                'text': 'text'
              };
              
              const targetDomain = domainMap[fileType];
              const domainPrompts = organized[targetDomain] || [];
              
              if (domainPrompts.length > 0) {
                // Mettre √† jour la s√©lection automatiquement
                setTimeout(() => onPromptChange(item.id, domainPrompts[0].id), 0);
              }
            }
            
            return Object.entries(organized).map(([domain, domainPrompts]) => (
              <optgroup key={domain} label={`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ${domain.toUpperCase()} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`}>
                {domainPrompts.map(prompt => (
                  <option key={prompt.id} value={prompt.id}>
                    {prompt.name}
                  </option>
                ))}
              </optgroup>
            ));
          })()}
        </select>
      </div>
    </div>
  );
};

// Composant pour afficher le type de fichier
const FileTypeDisplay: React.FC<{
  item: any;
  colors: any;
}> = ({ item, colors }) => {
  const getFileTypeInfo = () => {
    const fileName = item.file_info?.name || '';
    const fileExtension = fileName.split('.').pop()?.toLowerCase() || '';
    
    // D√©terminer le type de fichier bas√© sur l'extension
    if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg'].includes(fileExtension)) {
      return {
        label: 'Image',
        color: '#10b981', // Vert
        bgColor: 'rgba(16, 185, 129, 0.1)'
      };
    } else if (['mp4', 'avi', 'mov', 'wmv', 'flv', 'webm', 'mkv'].includes(fileExtension)) {
      return {
        label: 'Vid√©o',
        color: '#8b5cf6', // Violet
        bgColor: 'rgba(139, 92, 246, 0.1)'
      };
    } else if (['mp3', 'wav', 'flac', 'aac', 'ogg', 'wma'].includes(fileExtension)) {
      return {
        label: 'Audio',
        color: '#f59e0b', // Orange
        bgColor: 'rgba(245, 158, 11, 0.1)'
      };
    } else if (['pdf', 'doc', 'docx', 'txt', 'rtf', 'odt'].includes(fileExtension)) {
      return {
        label: 'Document',
        color: '#3b82f6', // Bleu
        bgColor: 'rgba(59, 130, 246, 0.1)'
      };
    } else {
      return {
        label: 'Texte',
        color: '#6b7280', // Gris
        bgColor: 'rgba(107, 114, 128, 0.1)'
      };
    }
  };

  const typeInfo = getFileTypeInfo();

  return (
    <span
      className="px-2 py-1 rounded text-xs font-medium"
      style={{
        backgroundColor: typeInfo.bgColor,
        color: typeInfo.color,
        border: `1px solid ${typeInfo.color}`
      }}
    >
      {typeInfo.label}
    </span>
  );
};

// Composant pour afficher le statut avec couleur
const StatusDisplay: React.FC<{
  item: any;
  colors: any;
}> = ({ item, colors }) => {
  const getStatusConfig = () => {
    switch (item.status) {
      case 'pending':
        return {
          label: 'En attente',
          color: '#f59e0b', // Orange
          bgColor: 'rgba(245, 158, 11, 0.1)'
        };
      case 'processing':
        return {
          label: 'En cours',
          color: '#3b82f6', // Bleu
          bgColor: 'rgba(59, 130, 246, 0.1)'
        };
      case 'completed':
        return {
          label: 'Termin√©',
          color: '#10b981', // Vert
          bgColor: 'rgba(16, 185, 129, 0.1)'
        };
      case 'failed':
        return {
          label: '√âchou√©',
          color: '#ef4444', // Rouge
          bgColor: 'rgba(239, 68, 68, 0.1)'
        };
      case 'paused':
        return {
          label: 'En pause',
          color: '#8b5cf6', // Violet
          bgColor: 'rgba(139, 92, 246, 0.1)'
        };
      default:
        return {
          label: 'Inconnu',
          color: colors.textSecondary,
          bgColor: 'rgba(107, 114, 128, 0.1)'
        };
    }
  };

  const config = getStatusConfig();

  return (
    <span
      className="px-2 py-1 rounded text-xs font-medium"
      style={{
        backgroundColor: config.bgColor,
        color: config.color,
        border: `1px solid ${config.color}`
      }}
    >
      {config.label}
    </span>
  );
};

// Composant pour les actions utilitaires (toutes les actions toujours visibles)
const UtilityActions: React.FC<{
  item: any;
  onAction: (action: string, itemId: string) => void;
  colors: any;
  localSelections: { [itemId: string]: { provider?: string; prompt?: string } };
}> = ({ item, onAction, colors, localSelections }) => {
  // Utiliser les s√©lections locales ou les valeurs par d√©faut
  const localSelection = localSelections[item.id] || {};
  const hasProvider = localSelection.provider !== undefined ? localSelection.provider : item.analysis_provider;
  const hasPrompt = localSelection.prompt !== undefined ? localSelection.prompt : item.analysis_prompt;
  const canStart = hasProvider && hasPrompt;
  
  // Configuration des actions avec ic√¥nes fixes et √©tats conditionnels
  const getActionConfig = () => {
    const baseConfig = {
      // Action principale (d√©marrer/pause/reprendre/relancer)
      primary: {
        icon: <PlayIcon className="w-4 h-4" />,
        tooltip: "D√©marrer l'analyse",
        variant: 'primary' as const,
        disabled: false,
        action: 'start_analysis'
      },
      // Visualisation
      view: {
        icon: <EyeIcon className="w-4 h-4" />,
        tooltip: "Visualiser le fichier analys√©",
        variant: 'info' as const,
        disabled: false,
        action: 'view_file'
      },
      // Duplication
      duplicate: {
        icon: <DocumentDuplicateIcon className="w-4 h-4" />,
        tooltip: "Dupliquer l'analyse",
        variant: 'primary' as const,
        disabled: false,
        action: 'duplicate_item'
      },
      // Suppression
      delete: {
        icon: <TrashIcon className="w-4 h-4" />,
        tooltip: "Supprimer l'analyse",
        variant: 'danger' as const,
        disabled: false,
        action: 'delete_item'
      }
    };

    // Ajuster selon le statut
    switch (item.status) {
      case 'pending':
        if (!canStart) {
          baseConfig.primary = {
            icon: <CogIcon className="w-4 h-4" />,
            tooltip: "Configurer l'analyse (IA et prompt requis)",
            variant: 'warning' as const,
            disabled: true,
            action: null
          };
        } else {
          baseConfig.primary = {
            icon: <PlayIcon className="w-4 h-4" />,
            tooltip: "D√©marrer l'analyse",
            variant: 'primary' as const,
            disabled: false,
            action: 'start_analysis'
          };
        }
                 baseConfig.view.disabled = true;
         baseConfig.view.tooltip = "Analyse en attente - visualisation indisponible";
         baseConfig.duplicate.disabled = false;
         baseConfig.duplicate.tooltip = "Dupliquer l'analyse en attente";
         baseConfig.delete.disabled = false;
         baseConfig.delete.tooltip = "Supprimer l'analyse en attente";
        break;

      case 'processing':
        baseConfig.primary = {
          icon: <PauseIcon className="w-4 h-4" />,
          tooltip: "Mettre en pause",
          variant: 'warning' as const,
          disabled: false,
          action: 'pause_item'
        };
                 baseConfig.view.disabled = true;
         baseConfig.view.tooltip = "Analyse en cours - visualisation indisponible";
         baseConfig.duplicate.disabled = false;
         baseConfig.duplicate.tooltip = "Dupliquer l'analyse en cours";
         baseConfig.delete.disabled = true;
         baseConfig.delete.tooltip = "Impossible de supprimer pendant le traitement";
        break;

      case 'paused':
        baseConfig.primary = {
          icon: <PlayIcon className="w-4 h-4" />,
          tooltip: "Reprendre l'analyse",
          variant: 'success' as const,
          disabled: false,
          action: 'retry_item'
        };
        baseConfig.view.disabled = true;
        baseConfig.view.tooltip = "Analyse en pause - visualisation indisponible";
        baseConfig.duplicate.disabled = false;
        baseConfig.duplicate.tooltip = "Dupliquer l'analyse en pause";
        baseConfig.delete.disabled = false;
        baseConfig.delete.tooltip = "Supprimer l'analyse en pause";
        break;

      case 'failed':
        baseConfig.primary = {
          icon: <ArrowPathIcon className="w-4 h-4" />,
          tooltip: "Relancer l'analyse",
          variant: 'warning' as const,
          disabled: false,
          action: 'retry_item'
        };
        baseConfig.view.disabled = true;
        baseConfig.view.tooltip = "Analyse √©chou√©e - visualisation indisponible";
        baseConfig.duplicate.disabled = false;
        baseConfig.duplicate.tooltip = "Dupliquer l'analyse √©chou√©e";
        baseConfig.delete.disabled = false;
        baseConfig.delete.tooltip = "Supprimer l'analyse √©chou√©e";
        break;

      case 'completed':
        baseConfig.primary = {
          icon: <ArrowPathIcon className="w-4 h-4" />,
          tooltip: "Relancer l'analyse termin√©e",
          variant: 'success' as const,
          disabled: false,
          action: 'retry_item'
        };
        baseConfig.view.disabled = false;
        baseConfig.view.tooltip = "Visualiser le fichier analys√©";
        baseConfig.duplicate.disabled = false;
        baseConfig.duplicate.tooltip = "Dupliquer l'analyse termin√©e";
        baseConfig.delete.disabled = false;
        baseConfig.delete.tooltip = "Supprimer l'analyse termin√©e";
        break;

      default:
        baseConfig.primary = {
          icon: <CogIcon className="w-4 h-4" />,
          tooltip: "Statut inconnu",
          variant: 'secondary' as const,
          disabled: true,
          action: null
        };
                 baseConfig.view.disabled = true;
         baseConfig.view.tooltip = "Statut inconnu - visualisation indisponible";
         baseConfig.duplicate.disabled = false;
         baseConfig.duplicate.tooltip = "Dupliquer l'analyse";
         baseConfig.delete.disabled = true;
         baseConfig.delete.tooltip = "Statut inconnu - suppression indisponible";
        break;
    }

    return baseConfig;
  };

  const actionConfig = getActionConfig();
  
  return (
    <div className="flex items-center gap-2">
      {/* Action principale (d√©marrer/pause/reprendre/relancer) */}
      <IconButton
        icon={actionConfig.primary.icon}
        onClick={() => actionConfig.primary.action && onAction(actionConfig.primary.action, item.id)}
        disabled={actionConfig.primary.disabled}
        variant={actionConfig.primary.variant}
        size="sm"
        tooltip={actionConfig.primary.tooltip}
        className={`transition-all duration-300 ease-in-out hover:scale-110 active:scale-95 ${
          actionConfig.primary.disabled ? 'opacity-50 cursor-not-allowed' : ''
        }`}
      />
      
      {/* Bouton de visualisation */}
      <IconButton
        icon={actionConfig.view.icon}
        onClick={() => onAction(actionConfig.view.action, item.id)}
        disabled={actionConfig.view.disabled}
        variant={actionConfig.view.variant}
        size="sm"
        tooltip={actionConfig.view.tooltip}
        className={`transition-all duration-300 ease-in-out hover:scale-110 active:scale-95 ${
          actionConfig.view.disabled ? 'opacity-50 cursor-not-allowed' : ''
        }`}
      />
      
      {/* Bouton de duplication */}
      <IconButton
        icon={actionConfig.duplicate.icon}
        onClick={() => onAction(actionConfig.duplicate.action, item.id)}
        disabled={actionConfig.duplicate.disabled}
        variant={actionConfig.duplicate.variant}
        size="sm"
        tooltip={actionConfig.duplicate.tooltip}
        className={`transition-all duration-300 ease-in-out hover:scale-110 active:scale-95 ${
          actionConfig.duplicate.disabled ? 'opacity-50 cursor-not-allowed' : ''
        }`}
      />
      
      {/* Bouton de suppression */}
      <IconButton
        icon={actionConfig.delete.icon}
        onClick={() => onAction(actionConfig.delete.action, item.id)}
        disabled={actionConfig.delete.disabled}
        variant={actionConfig.delete.variant}
        size="sm"
        tooltip={actionConfig.delete.tooltip}
        className={`transition-all duration-300 ease-in-out hover:scale-110 active:scale-95 ${
          actionConfig.delete.disabled ? 'opacity-50 cursor-not-allowed' : ''
        }`}
      />
    </div>
  );
};

interface QueueTableProps {
  items: any[];
  onAction: (action: string, itemId: string) => void;
  selectedItems: string[];
  onSelectionChange: (itemIds: string[]) => void;
  prompts: Prompt[];
  onPromptChange: (itemId: string, promptId: string) => void;
  onProviderChange: (itemId: string, provider: string) => void;
  localSelections: { [itemId: string]: { provider?: string; prompt?: string } };
}

interface QueueFiltersProps {
  filters: any;
  onFilterChange: (filters: any) => void;
}

// Composant de tableau simplifi√©
const QueueTable: React.FC<QueueTableProps> = ({ 
  items, 
  onAction, 
  selectedItems, 
  onSelectionChange, 
  prompts,
  onPromptChange,
  onProviderChange,
  localSelections
}) => {
  const { colors } = useColors();
  const [sortConfig, setSortConfig] = useState({ key: '', direction: 'asc' as 'asc' | 'desc' });
  
  const handleSort = (key: string, direction: 'asc' | 'desc') => {
    setSortConfig({ key, direction });
    logService.debug(`Tri de la colonne ${key} en ${direction}`, 'QueueIAAdvanced', { key, direction });
  };

  // D√©finition des colonnes simplifi√©es
  const columns: TableColumn<any>[] = [
    {
      key: 'file',
      label: 'Fichier',
      sortable: true,
      render: (item) => (
        <FileInfo 
          item={item} 
          colors={colors}
        />
      )
    },
    {
      key: 'file_type',
      label: 'Type',
      sortable: true,
      render: (item) => (
        <FileTypeDisplay 
          item={item} 
          colors={colors}
        />
      )
    },
    {
      key: 'configuration',
      label: 'Configuration',
      sortable: false,
             render: (item) => (
         <ConfigurationCompact
           item={item}
           colors={colors}
           prompts={prompts}
           onProviderChange={onProviderChange}
           onPromptChange={onPromptChange}
           localSelections={localSelections}
         />
       )
    },
         {
       key: 'status',
       label: 'Statut',
       sortable: true,
       render: (item) => (
         <StatusDisplay
           item={item}
           colors={colors}
         />
       )
     },
         {
       key: 'actions',
       label: 'Actions',
       sortable: false,
       render: (item) => (
         <UtilityActions
           item={item}
           onAction={onAction}
           colors={colors}
           localSelections={localSelections}
         />
       )
     }
  ];
  
  return (
    <UnifiedTable
      data={items}
      columns={columns}
      selectedItems={selectedItems}
      onSelectionChange={onSelectionChange}
      onSort={handleSort}
      sortConfig={sortConfig}
      getItemId={(item) => item.id}
      showCheckbox={true}
    />
  );
};

// Composant de filtres simplifi√©
const QueueFilters: React.FC<QueueFiltersProps> = ({ filters, onFilterChange }) => {
  const { colors } = useColors();
  
  return (
    <div className="mb-4 p-3 rounded-lg border" style={{
      backgroundColor: colors.surface,
      borderColor: colors.border,
    }}>
      <div className="flex items-center gap-3 flex-wrap">
        <div className="flex items-center gap-2">
          <FunnelIcon className="w-4 h-4" style={{ color: colors.textSecondary }} />
          <span className="text-sm font-medium" style={{ color: colors.text }}>
            Filtres
          </span>
        </div>
        
        <select
          value={filters.status}
          onChange={(e) => onFilterChange({ ...filters, status: e.target.value })}
          className="px-2 py-1 rounded text-xs border"
          style={{
            backgroundColor: colors.background,
            borderColor: colors.border,
            color: colors.text,
            minWidth: '120px'
          }}
        >
          <option value="">Tous les statuts</option>
          <option value="pending">En attente</option>
          <option value="processing">En cours</option>
          <option value="completed">Termin√©</option>
          <option value="failed">√âchou√©</option>
          <option value="paused">En pause</option>
        </select>
        
        
        
        <select
          value={filters.file_type}
          onChange={(e) => onFilterChange({ ...filters, file_type: e.target.value })}
          className="px-2 py-1 rounded text-xs border"
          style={{
            backgroundColor: colors.background,
            borderColor: colors.border,
            color: colors.text,
            minWidth: '120px'
          }}
        >
          <option value="">Tous les types de fichiers</option>
          <option value="text">Texte</option>
          <option value="image">Image</option>
          <option value="video">Vid√©o</option>
          <option value="audio">Audio</option>
          <option value="document">Document</option>
        </select>
        
        
        
                 <div className="flex-1 relative">
           <input
             type="text"
             placeholder="Rechercher par nom de fichier..."
             value={filters.search}
             onChange={(e) => onFilterChange({ ...filters, search: e.target.value })}
             className="px-2 py-1 rounded text-xs border w-full"
             style={{
               backgroundColor: colors.background,
               borderColor: colors.border,
               color: colors.text,
               minWidth: '150px'
             }}
             title="Recherche par nom de fichier uniquement. Utilisez ';' pour s√©parer plusieurs termes (ex: fichier1.pdf;fichier2.jpg)"
           />
           <div 
             className="absolute right-2 top-1/2 transform -translate-y-1/2 cursor-help"
             title="Recherche par nom de fichier uniquement. Utilisez ';' pour s√©parer plusieurs termes (ex: fichier1.pdf;fichier2.jpg)"
           >
             <span className="text-xs" style={{ color: colors.textSecondary }}>‚ìò</span>
           </div>
         </div>
        
                 <button
           onClick={() => onFilterChange({ status: '', file_type: '', search: '' })}
           className="px-2 py-1 text-xs rounded border hover:opacity-80 transition-opacity"
           style={{
             backgroundColor: colors.background,
             borderColor: colors.border,
             color: colors.textSecondary,
           }}
         >
           R√©initialiser
         </button>
      </div>
    </div>
  );
};

// Composant principal simplifi√©
export const QueueIAAdvanced: React.FC = () => {
  const { colors } = useColors();
  const { queueItems, loadQueueItems } = useQueueStore();
  const { prompts, loading: loadingPrompts, getPrompts } = usePromptStore();
  const { loadAIProviders, refreshAIProviders, isInitialized: configInitialized, getAIProviders } = useConfigStore();
  
  const currentPrompts = getPrompts();
  const allAIProviders = getAIProviders();
  
  React.useEffect(() => {
    logService.info(`üîÑ Chargement initial de la queue IA avanc√©e`, 'QueueIAAdvanced');
    loadQueueItems();
    if (!configInitialized) {
      logService.info(`‚öôÔ∏è Chargement de la configuration IA`, 'QueueIAAdvanced');
      loadAIProviders();
    } else {
      // Rafra√Æchir la configuration IA pour s'assurer d'avoir les derni√®res donn√©es
      logService.info(`üîÑ Rafra√Æchissement de la configuration IA`, 'QueueIAAdvanced');
      refreshAIProviders();
    }
  }, [loadQueueItems, loadAIProviders, refreshAIProviders, configInitialized]);




  
  const [selectedItems, setSelectedItems] = useState<string[]>([]);
     const [filters, setFilters] = useState({
     status: '',
     file_type: '',
     search: ''
   });
  
  // √âtat local pour les s√©lections d'IA et prompt
  const [localSelections, setLocalSelections] = useState<{
    [itemId: string]: {
      provider?: string;
      prompt?: string;
    }
  }>({});

  // Appliquer les filtres aux donn√©es
  const filteredItems = React.useMemo(() => {
    return queueItems.filter(item => {
      // Filtre par statut
      if (filters.status && item.status !== filters.status) {
        return false;
      }
      
             // Filtre par recherche (nom de fichier) - support recherche multiple avec s√©parateur ';'
       if (filters.search) {
         const fileName = item.file_info?.name || '';
         const searchTerms = filters.search.split(';').map(term => term.trim().toLowerCase()).filter(term => term.length > 0);
         
         // Si aucun terme valide, ne pas filtrer
         if (searchTerms.length === 0) {
           return true;
         }
         
         // V√©rifier si au moins un terme correspond
         const fileNameLower = fileName.toLowerCase();
         const hasMatch = searchTerms.some(term => fileNameLower.includes(term));
         
         if (!hasMatch) {
           return false;
         }
       }
      
      
      
      // Filtre par type de fichier
      if (filters.file_type) {
        const fileName = item.file_info?.name || '';
        const fileExtension = fileName.split('.').pop()?.toLowerCase() || '';
        let fileType = 'text';
        
        if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg'].includes(fileExtension)) {
          fileType = 'image';
        } else if (['mp4', 'avi', 'mov', 'wmv', 'flv', 'webm', 'mkv'].includes(fileExtension)) {
          fileType = 'video';
        } else if (['mp3', 'wav', 'flac', 'aac', 'ogg', 'wma'].includes(fileExtension)) {
          fileType = 'audio';
        } else if (['pdf', 'doc', 'docx', 'txt', 'rtf', 'odt'].includes(fileExtension)) {
          fileType = 'document';
        }
        
        // Debug pour voir ce qui se passe avec le filtre
        console.log(`üîç Filtre type fichier pour ${fileName}:`, {
          fileExtension,
          calculatedFileType: fileType,
          filterValue: filters.file_type,
          matches: fileType === filters.file_type
        });
        
        if (fileType !== filters.file_type) {
          return false;
        }
      }
      
      
      
      return true;
    });
  }, [queueItems, filters]);

  // Initialiser les s√©lections locales avec les valeurs de la base de donn√©es
  React.useEffect(() => {
    if (queueItems.length > 0 && currentPrompts.length > 0 && configInitialized) {
      logService.info(`‚öôÔ∏è Initialisation des s√©lections locales pour ${queueItems.length} analyses`, 'QueueIAAdvanced');
      
      const initialSelections: { [itemId: string]: { provider?: string; prompt?: string } } = {};
      
      queueItems.forEach(item => {
        if (item.analysis_provider || item.analysis_prompt) {
          // Pour les prompts, on doit trouver l'ID correspondant au contenu
          let promptId = undefined;
          if (item.analysis_prompt) {
            const matchingPrompt = currentPrompts.find(p => p.prompt === item.analysis_prompt);
            promptId = matchingPrompt?.id;
          }
          
          initialSelections[item.id] = {
            provider: item.analysis_provider || undefined,
            prompt: promptId
          };
        }
      });
      
      setLocalSelections(prev => ({
        ...prev,
        ...initialSelections
      }));
      
                  logService.info(`‚úÖ S√©lections locales initialis√©es pour ${Object.keys(initialSelections).length} analyses`, 'QueueIAAdvanced');
    }
  }, [queueItems, currentPrompts, configInitialized]);
  
  const { simpleDelete, simpleAction } = useSimpleConfirm();

  // G√©rer le changement de prompt (mise √† jour locale uniquement)
  const handlePromptChange = (itemId: string, promptId: string) => {
    const item = queueItems.find(q => q.id.toString() === itemId);
    const itemName = item?.file_info?.name || `ID: ${itemId}`;
    
    // Trouver le nom du prompt s√©lectionn√©
    const selectedPrompt = currentPrompts.find(p => p.id === promptId);
    const promptName = selectedPrompt ? `${selectedPrompt.name} (${selectedPrompt.domain})` : 'Prompt non trouv√©';
    
    logService.info(`üìù Changement de prompt pour ${itemName}: ${promptName}`, 'QueueIAAdvanced', { 
      itemId, 
      promptId, 
      itemName, 
      promptName 
    });
    
    // Mise √† jour de l'√©tat local
    setLocalSelections(prev => ({
      ...prev,
      [itemId]: {
        ...prev[itemId],
        prompt: promptId
      }
    }));
  };

  // G√©rer le changement de fournisseur IA (mise √† jour locale uniquement)
  const handleProviderChange = (itemId: string, providerId: string) => {
    const item = queueItems.find(q => q.id.toString() === itemId);
    const itemName = item?.file_info?.name || `ID: ${itemId}`;
    
    // Trouver le nom du provider s√©lectionn√©
    const selectedProvider = allAIProviders.find(p => p.name === providerId);
    const providerName = selectedProvider ? selectedProvider.name : providerId;
    
    logService.info(`ü§ñ Changement de fournisseur IA pour ${itemName}: ${providerName}`, 'QueueIAAdvanced', { 
      itemId, 
      providerId, 
      itemName, 
      providerName 
    });
    
    // Mise √† jour de l'√©tat local
    setLocalSelections(prev => ({
      ...prev,
      [itemId]: {
        ...prev[itemId],
        provider: providerId
      }
    }));
  };

    const handleAction = async (action: string, itemId: string, additionalData?: any) => {
    try {
      const item = queueItems.find(q => q.id.toString() === itemId);
      if (!item) {
        logService.error(`‚ùå √âl√©ment non trouv√© pour l'action ${action}`, 'QueueIAAdvanced', { action, itemId });
        return;
      }
      
      const itemName = item?.file_info?.name || `ID: ${itemId}`;
      const itemStatus = item.status;
      
      logService.info(`üîÑ Action ${action} sur ${itemName} (statut: ${itemStatus})`, 'QueueIAAdvanced', { action, itemId, itemName, itemStatus });
      
             // Validation des actions selon le statut
       const validateAction = (action: string, status: string): boolean => {
         const validations = {
           'view_file': ['completed'],
           'duplicate_item': ['completed', 'failed', 'paused', 'pending', 'processing'],
           'delete_item': ['completed', 'failed', 'pending', 'paused'],
           'start_analysis': ['pending'],
           'retry_item': ['failed', 'paused'],
           'pause_item': ['processing'],
           'generate_pdf': ['completed']
         };
        
        const allowedStatuses = validations[action] || [];
        const isValid = allowedStatuses.includes(status);
        
        if (!isValid) {
          logService.warning(`‚ö†Ô∏è Action ${action} non autoris√©e pour le statut ${status}`, 'QueueIAAdvanced', { 
            action, 
            status, 
            allowedStatuses, 
            itemName 
          });
        }
        
        return isValid;
      };
      
      // V√©rifier si l'action est autoris√©e pour le statut actuel
      if (!validateAction(action, itemStatus)) {
        return;
      }
      
      switch (action) {
        case 'retry_item':
          if (itemStatus !== 'failed' && itemStatus !== 'paused') {
            logService.warning(`‚ö†Ô∏è Impossible de relancer l'analyse ${itemName} - statut: ${itemStatus}`, 'QueueIAAdvanced', { itemId, itemName, itemStatus });
            return;
          }
          logService.info(`üîÑ Relance de l'analyse ${itemName}`, 'QueueIAAdvanced', { itemId, itemName, itemStatus });
          await queueService.retryQueueItem(parseInt(itemId));
          logService.info(`‚úÖ Analyse ${itemName} relanc√©e avec succ√®s`, 'QueueIAAdvanced', { itemId, itemName });
          break;
          
        case 'view_file':
          if (itemStatus !== 'completed') {
            logService.warning(`‚ö†Ô∏è Impossible de visualiser ${itemName} - analyse non termin√©e (statut: ${itemStatus})`, 'QueueIAAdvanced', { itemId, itemName, itemStatus });
            return;
          }
          logService.info(`üëÅÔ∏è Ouverture du fichier ${itemName} pour visualisation`, 'QueueIAAdvanced', { itemId, itemName });
          // TODO: Impl√©menter l'ouverture du fichier dans l'onglet visualisation
          break;
          
        case 'generate_pdf':
          if (itemStatus !== 'completed') {
            logService.warning(`‚ö†Ô∏è Impossible de g√©n√©rer le PDF pour ${itemName} - analyse non termin√©e (statut: ${itemStatus})`, 'QueueIAAdvanced', { itemId, itemName, itemStatus });
            return;
          }
          logService.info(`üìÑ G√©n√©ration du PDF pour ${itemName}`, 'QueueIAAdvanced', { itemId, itemName });
          await pdfService.generateAnalysisPDF(parseInt(itemId));
          logService.info(`‚úÖ PDF g√©n√©r√© pour ${itemName}`, 'QueueIAAdvanced', { itemId, itemName });
          break;
          
                 case 'duplicate_item':
          logService.info(`üìã Duplication de l'analyse ${itemName}`, 'QueueIAAdvanced', { itemId, itemName, itemStatus });
          
          // R√©cup√©rer les s√©lections locales ou les valeurs par d√©faut pour la duplication
          const duplicateLocalSelection = localSelections[itemId] || {};
          const duplicateProvider = duplicateLocalSelection.provider || item.analysis_provider;
          
          // Pour les prompts, on doit r√©cup√©rer le contenu du prompt s√©lectionn√©
          let duplicatePrompt = '';
          if (duplicateLocalSelection.prompt) {
            const selectedPromptObj = currentPrompts.find(p => p.id === duplicateLocalSelection.prompt);
            duplicatePrompt = selectedPromptObj?.prompt || '';
          } else if (item.analysis_prompt) {
            duplicatePrompt = item.analysis_prompt;
          }
         
         try {
           const result = await queueService.duplicateAnalysis(
             parseInt(itemId), 
             duplicateProvider, 
             duplicatePrompt
           );
           
           logService.info(`‚úÖ Analyse ${itemName} dupliqu√©e avec succ√®s`, 'QueueIAAdvanced', { 
             itemId, 
             itemName, 
             newItemId: result.new_item_id,
             newAnalysisId: result.new_analysis_id,
             provider: duplicateProvider,
             prompt: duplicatePrompt.substring(0, 100) + '...'
           });
           
           // Rafra√Æchir la queue pour afficher la nouvelle ligne
           await loadQueueItems();
           
         } catch (error) {
           logService.error(`‚ùå Erreur lors de la duplication de l'analyse ${itemName}`, 'QueueIAAdvanced', { 
             itemId, 
             itemName, 
             error: error.message 
           });
         }
         break;
         
        case 'delete_item':
          if (itemStatus === 'processing') {
            logService.warning(`‚ö†Ô∏è Impossible de supprimer ${itemName} - analyse en cours (statut: ${itemStatus})`, 'QueueIAAdvanced', { itemId, itemName, itemStatus });
            return;
          }
          logService.warning(`üóëÔ∏è Suppression de l'analyse ${itemName}`, 'QueueIAAdvanced', { itemId, itemName, itemStatus });
          try {
            await queueService.deleteQueueItem(parseInt(itemId));
            logService.info(`‚úÖ Analyse ${itemName} supprim√©e avec succ√®s`, 'QueueIAAdvanced', { itemId, itemName });
            
            // Forcer la mise √† jour imm√©diate du store
            await loadQueueItems();
            
            // Nettoyer les s√©lections locales pour cet item
            setLocalSelections(prev => {
              const newSelections = { ...prev };
              delete newSelections[itemId];
              return newSelections;
            });
            
          } catch (error) {
            logService.error(`‚ùå Erreur lors de la suppression de l'analyse ${itemName}`, 'QueueIAAdvanced', { itemId, itemName, error: error.message });
          }
          break;
          
        case 'start_analysis':
          if (itemStatus !== 'pending') {
            logService.warning(`‚ö†Ô∏è Impossible de d√©marrer ${itemName} - analyse non en attente (statut: ${itemStatus})`, 'QueueIAAdvanced', { itemId, itemName, itemStatus });
            return;
          }
          logService.info(`üöÄ D√©marrage de l'analyse ${itemName}`, 'QueueIAAdvanced', { itemId, itemName });
          
          // R√©cup√©rer les s√©lections locales ou les valeurs par d√©faut
          const startLocalSelection = localSelections[itemId] || {};
          const selectedProvider = startLocalSelection.provider || item.analysis_provider;
          
          // Pour les prompts, on doit r√©cup√©rer le contenu du prompt s√©lectionn√©
          let selectedPrompt = '';
          if (startLocalSelection.prompt) {
            const selectedPromptObj = currentPrompts.find(p => p.id === startLocalSelection.prompt);
            selectedPrompt = selectedPromptObj?.prompt || '';
          } else if (item.analysis_prompt) {
            selectedPrompt = item.analysis_prompt;
          }
         
         if (!selectedProvider || !selectedPrompt) {
           logService.warning(`‚ö†Ô∏è Impossible de d√©marrer l'analyse ${itemName} - IA ou prompt manquant`, 'QueueIAAdvanced', { 
             itemId, 
             itemName, 
             selectedProvider, 
             selectedPrompt 
           });
           return;
         }
         
         logService.info(`‚öôÔ∏è Configuration de l'analyse ${itemName}`, 'QueueIAAdvanced', { 
           itemId, 
           itemName, 
           provider: selectedProvider, 
           prompt: selectedPrompt.substring(0, 100) + '...' 
         });
         
         // Envoyer la requ√™te au backend pour mettre √† jour et d√©marrer l'analyse
         try {
           await queueService.updateAnalysisProviderAndPrompt(
             parseInt(itemId), 
             selectedProvider, 
             selectedPrompt
           );
           logService.info(`‚úÖ Analyse ${itemName} d√©marr√©e avec succ√®s`, 'QueueIAAdvanced', { 
             itemId, 
             itemName, 
             provider: selectedProvider, 
             prompt: selectedPrompt.substring(0, 100) + '...' 
           });
           await loadQueueItems();
         } catch (error) {
           logService.error(`‚ùå Erreur lors du d√©marrage de l'analyse ${itemName}`, 'QueueIAAdvanced', { itemId, itemName, error: error.message });
         }
         break;
         
        case 'pause_item':
          if (itemStatus !== 'processing') {
            logService.warning(`‚ö†Ô∏è Impossible de mettre en pause ${itemName} - analyse non en cours (statut: ${itemStatus})`, 'QueueIAAdvanced', { itemId, itemName, itemStatus });
            return;
          }
          logService.info(`‚è∏Ô∏è Mise en pause de l'analyse ${itemName}`, 'QueueIAAdvanced', { itemId, itemName });
          // TODO: Impl√©menter la pause
          break;
          
        default:
          logService.warning(`‚ö†Ô∏è Action non reconnue: ${action}`, 'QueueIAAdvanced', { action, itemId, itemName });
      }
      
      // Rafra√Æchir la queue apr√®s chaque action
      await loadQueueItems();
      
    } catch (error) {
      logService.error(`‚ùå Erreur lors de l'ex√©cution de l'action ${action}`, 'QueueIAAdvanced', { action, itemId, error: error.message });
    }
  };
  
  const handleSelectionChange = (itemIds: string[]) => {
    if (itemIds.length !== selectedItems.length) {
      logService.info(`üìã Changement de s√©lection: ${itemIds.length} √©l√©ments s√©lectionn√©s`, 'QueueIAAdvanced', { 
        selectedItems: itemIds 
      });
    }
    setSelectedItems(itemIds);
  };
  
  const handleBulkAction = async (action: string) => {
    if (selectedItems.length === 0) return;
    
    try {
      logService.info(`üîÑ Action en lot ${action} sur ${selectedItems.length} √©l√©ments`, 'QueueIAAdvanced', { action, selectedItems });
      
      switch (action) {
        case 'pause_all':
          logService.info(`‚è∏Ô∏è Mise en pause de toute la queue`, 'QueueIAAdvanced');
          await queueService.pauseQueue();
                     logService.info(`‚úÖ Queue mise en pause avec succ√®s`, 'QueueIAAdvanced');
          break;
        case 'resume_all':
          logService.info(`‚ñ∂Ô∏è Reprise de toute la queue`, 'QueueIAAdvanced');
          await queueService.resumeQueue();
                     logService.info(`‚úÖ Queue reprise avec succ√®s`, 'QueueIAAdvanced');
          break;
        case 'retry_failed':
          logService.info(`üîÑ Relance de toutes les analyses √©chou√©es`, 'QueueIAAdvanced');
          await queueService.retryFailedItems();
                     logService.info(`‚úÖ Analyses √©chou√©es relanc√©es avec succ√®s`, 'QueueIAAdvanced');
          break;
                 case 'clear_completed':
           logService.warning(`üóëÔ∏è Suppression de toutes les analyses termin√©es`, 'QueueIAAdvanced');
           simpleAction(
             'supprimer toutes les analyses termin√©es',
             'les analyses termin√©es',
             async () => {
               await queueService.clearQueue();
                              logService.info(`‚úÖ Analyses termin√©es supprim√©es avec succ√®s`, 'QueueIAAdvanced');
               setSelectedItems([]);
             },
             undefined,
             'danger'
           );
           return;
         case 'compare_selected':
           if (selectedItems.length < 2) {
             logService.warning(`‚ö†Ô∏è Impossible de comparer - au moins 2 √©l√©ments requis`, 'QueueIAAdvanced', { selectedItems });
             return;
           }
           logService.info(`‚öñÔ∏è Comparaison de ${selectedItems.length} analyses s√©lectionn√©es`, 'QueueIAAdvanced', { selectedItems });
           
           // R√©cup√©rer les d√©tails des √©l√©ments s√©lectionn√©s
           const selectedItemsDetails = queueItems.filter(item => selectedItems.includes(item.id.toString()));
           const selectedFileNames = selectedItemsDetails.map(item => item.file_info?.name || `ID: ${item.id}`);
           
           logService.info(`üìã Fichiers √† comparer: ${selectedFileNames.join(', ')}`, 'QueueIAAdvanced', { 
             selectedItems, 
             fileNames: selectedFileNames 
           });
           
           // TODO: Impl√©menter la logique de comparaison
           // Pour l'instant, on affiche juste les informations dans les logs
           console.log('üîç Comparaison des analyses:', {
             selectedItems,
             fileNames: selectedFileNames,
             details: selectedItemsDetails.map(item => ({
               id: item.id,
               name: item.file_info?.name,
               status: item.status,
               provider: item.analysis_provider,
               prompt: item.analysis_prompt?.substring(0, 100) + '...'
             }))
           });
           
           // TODO: Ouvrir une modal ou naviguer vers une page de comparaison
           // TODO: Impl√©menter l'API de comparaison c√¥t√© backend
           break;
         default:
           logService.warning(`‚ö†Ô∏è Action en lot non reconnue: ${action}`, 'QueueIAAdvanced', { action });
      }
      if (action !== 'clear_completed') {
        setSelectedItems([]);
      }
    } catch (error) {
      logService.error(`‚ùå Erreur lors de l'action en lot ${action}`, 'QueueIAAdvanced', { action, error: error.message });
    }
  };
  
  return (
    <div className="h-full flex flex-col overflow-hidden" style={{ backgroundColor: colors.background }}>
      <div className="p-4 border-b flex-shrink-0" style={{ borderColor: colors.border }}>
        <h1 className="text-xl font-bold" style={{ color: colors.text }}>
          Queue IA Avanc√©e
        </h1>
        <p className="text-sm" style={{ color: colors.textSecondary }}>
          Gestion simplifi√©e de la queue d'analyses
        </p>
      </div>
      
      <div className="flex-1 flex flex-col p-4 min-h-0">
        
        {/* Actions globales */}
        <div className="mb-4 p-3 rounded-lg border flex-shrink-0" style={{
          backgroundColor: colors.surface,
          borderColor: colors.border,
        }}>
          <div className="flex items-center justify-between flex-wrap gap-3">
                         <div className="flex items-center gap-2">
               <span className="text-sm font-medium" style={{ color: colors.text }}>
                 Actions globales:
               </span>
               <Button
                 onClick={() => handleBulkAction('pause_all')}
                 variant="warning"
                 size="sm"
                 icon={<PauseIcon />}
                 className="transition-all duration-300 ease-in-out hover:scale-105 active:scale-95"
               >
                 Pause
               </Button>
               <Button
                 onClick={() => handleBulkAction('resume_all')}
                 variant="success"
                 size="sm"
                 icon={<PlayIcon />}
                 className="transition-all duration-300 ease-in-out hover:scale-105 active:scale-95"
               >
                 Reprendre
               </Button>
               <Button
                 onClick={() => handleBulkAction('retry_failed')}
                 variant="primary"
                 size="sm"
                 icon={<ArrowPathIcon />}
                 className="transition-all duration-300 ease-in-out hover:scale-105 active:scale-95"
               >
                 Relancer
               </Button>
               <Button
                 onClick={() => handleBulkAction('clear_completed')}
                 variant="danger"
                 size="sm"
                 icon={<TrashIcon />}
                 className="transition-all duration-300 ease-in-out hover:scale-105 active:scale-95"
               >
                 Vider
               </Button>
                               <Button
                  onClick={() => handleBulkAction('compare_selected')}
                  variant="info"
                  size="sm"
                  icon={<Squares2X2Icon />}
                  disabled={selectedItems.length < 2}
                  className={`transition-all duration-300 ease-in-out hover:scale-105 active:scale-95 ${
                    selectedItems.length < 2 ? 'opacity-50 cursor-not-allowed' : ''
                  }`}
                >
                  Comparer ({selectedItems.length})
                </Button>
             </div>
            
            <div className="flex items-center gap-2">
              <span className="text-xs" style={{ color: colors.textSecondary }}>
                {selectedItems.length} √©l√©ment(s) s√©lectionn√©(s)
              </span>
              {selectedItems.length > 0 && (
                <button
                  onClick={() => setSelectedItems([])}
                  className="text-xs px-2 py-1 rounded border hover:opacity-80 transition-opacity"
                  style={{
                    backgroundColor: colors.background,
                    borderColor: colors.border,
                    color: colors.textSecondary,
                  }}
                >
                  D√©s√©lectionner
                </button>
              )}
            </div>
          </div>
        </div>
        
        {/* Filtres */}
        <div className="flex-shrink-0">
          <QueueFilters filters={filters} onFilterChange={setFilters} />
        </div>
        
        {/* Tableau avec scroll */}
        <div className="flex-1 rounded-lg border min-h-0" style={{
          backgroundColor: colors.surface,
          borderColor: colors.border,
        }}>
          <div className="h-full overflow-y-auto">
            {loadingPrompts ? (
              <div className="flex items-center justify-center h-32">
                <div className="text-center">
                  <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
                  <span style={{ color: colors.textSecondary }}>Chargement des prompts...</span>
                </div>
              </div>
            ) : (
                                             <QueueTable
                  items={filteredItems}
                  onAction={handleAction}
                  selectedItems={selectedItems}
                  onSelectionChange={handleSelectionChange}
                  prompts={currentPrompts}
                  onPromptChange={handlePromptChange}
                  onProviderChange={handleProviderChange}
                  localSelections={localSelections}
                />
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default QueueIAAdvanced;
